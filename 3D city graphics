<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D City</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial;
            text-shadow: 1px 1px 1px black;
            pointer-events: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial;
            font-size: 24px;
            text-shadow: 1px 1px 1px black;
        }
    </style>
</head>
<body>
    <div id="info">Drag to look around | Scroll to zoom</div>
    <div id="loading">Loading 3D City...</div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Show loading message
        const loadingElement = document.getElementById('loading');
        
        // Main scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        
        // Renderer with antialiasing
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // Camera
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 100);
        
        // Controls (mouse/touch)
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 30;
        controls.maxDistance = 200;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        
        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 1024;
        sunLight.shadow.mapSize.height = 1024;
        scene.add(sunLight);
        
        // Ground
        const groundGeometry = new THREE.PlaneGeometry(500, 500);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x333333,
            roughness: 0.8
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI/2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Buildings
        function createBuilding(x, z, width, height, depth, color) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.7
            });
            const building = new THREE.Mesh(geometry, material);
            building.position.set(x, height/2, z);
            building.castShadow = true;
            building.receiveShadow = true;
            scene.add(building);
            
            // Add windows if building is tall enough
            if(height > 20) {
                const windowGeometry = new THREE.PlaneGeometry(width-2, height-5);
                const windowMaterial = new THREE.MeshStandardMaterial({
                    color: 0x88ccff,
                    emissive: 0x111111,
                    emissiveIntensity: 0.2,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const windows = new THREE.Mesh(windowGeometry, windowMaterial);
                windows.position.set(x, height/2, z + depth/2 + 0.1);
                windows.rotation.y = Math.PI;
                scene.add(windows);
            }
            
            return building;
        }
        
        // Create city grid
        const buildingColors = [0xaaaaaa, 0xbbbbbb, 0x999999, 0xcccccc];
        for(let x = -150; x <= 150; x += 50) {
            for(let z = -150; z <= 150; z += 50) {
                if(Math.random() > 0.3) {
                    const height = 10 + Math.random() * 50;
                    const width = 10 + Math.random() * 15;
                    const depth = 10 + Math.random() * 15;
                    const color = buildingColors[Math.floor(Math.random() * buildingColors.length)];
                    
                    createBuilding(x, z, width, height, depth, color);
                }
            }
        }
        
        // Roads
        const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
        for(let x = -200; x <= 200; x += 50) {
            const road = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 500),
                roadMaterial
            );
            road.rotation.x = -Math.PI/2;
            road.position.set(x, 0.1, 0);
            scene.add(road);
        }
        for(let z = -200; z <= 200; z += 50) {
            const road = new THREE.Mesh(
                new THREE.PlaneGeometry(500, 10),
                roadMaterial
            );
            road.rotation.x = -Math.PI/2;
            road.position.set(0, 0.1, z);
            scene.add(road);
        }
        
        // Hide loading message when ready
        loadingElement.style.display = 'none';
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html><!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D City</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial;
            text-shadow: 1px 1px 1px black;
            pointer-events: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial;
            font-size: 24px;
            text-shadow: 1px 1px 1px black;
        }
    </style>
</head>
<body>
    <div id="info">Drag to look around | Scroll to zoom</div>
    <div id="loading">Loading 3D City...</div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Show loading message
        const loadingElement = document.getElementById('loading');
        
        // Main scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        
        // Renderer with antialiasing
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // Camera
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 100);
        
        // Controls (mouse/touch)
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 30;
        controls.maxDistance = 200;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        
        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 1024;
        sunLight.shadow.mapSize.height = 1024;
        scene.add(sunLight);
        
        // Ground
        const groundGeometry = new THREE.PlaneGeometry(500, 500);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x333333,
            roughness: 0.8
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI/2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Buildings
        function createBuilding(x, z, width, height, depth, color) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.7
            });
            const building = new THREE.Mesh(geometry, material);
            building.position.set(x, height/2, z);
            building.castShadow = true;
            building.receiveShadow = true;
            scene.add(building);
            
            // Add windows if building is tall enough
            if(height > 20) {
                const windowGeometry = new THREE.PlaneGeometry(width-2, height-5);
                const windowMaterial = new THREE.MeshStandardMaterial({
                    color: 0x88ccff,
                    emissive: 0x111111,
                    emissiveIntensity: 0.2,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const windows = new THREE.Mesh(windowGeometry, windowMaterial);
                windows.position.set(x, height/2, z + depth/2 + 0.1);
                windows.rotation.y = Math.PI;
                scene.add(windows);
            }
            
            return building;
        }
        
        // Create city grid
        const buildingColors = [0xaaaaaa, 0xbbbbbb, 0x999999, 0xcccccc];
        for(let x = -150; x <= 150; x += 50) {
            for(let z = -150; z <= 150; z += 50) {
                if(Math.random() > 0.3) {
                    const height = 10 + Math.random() * 50;
                    const width = 10 + Math.random() * 15;
                    const depth = 10 + Math.random() * 15;
                    const color = buildingColors[Math.floor(Math.random() * buildingColors.length)];
                    
                    createBuilding(x, z, width, height, depth, color);
                }
            }
        }
        
        // Roads
        const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
        for(let x = -200; x <= 200; x += 50) {
            const road = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 500),
                roadMaterial
            );
            road.rotation.x = -Math.PI/2;
            road.position.set(x, 0.1, 0);
            scene.add(road);
        }
        for(let z = -200; z <= 200; z += 50) {
            const road = new THREE.Mesh(
                new THREE.PlaneGeometry(500, 10),
                roadMaterial
            );
            road.rotation.x = -Math.PI/2;
            road.position.set(0, 0.1, z);
            scene.add(road);
        }
        
        // Hide loading message when ready
        loadingElement.style.display = 'none';
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html><!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D City</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial;
            text-shadow: 1px 1px 1px black;
            pointer-events: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial;
            font-size: 24px;
            text-shadow: 1px 1px 1px black;
        }
    </style>
</head>
<body>
    <div id="info">Drag to look around | Scroll to zoom</div>
    <div id="loading">Loading 3D City...</div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Show loading message
        const loadingElement = document.getElementById('loading');
        
        // Main scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        
        // Renderer with antialiasing
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // Camera
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 100);
        
        // Controls (mouse/touch)
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 30;
        controls.maxDistance = 200;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        
        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 1024;
        sunLight.shadow.mapSize.height = 1024;
        scene.add(sunLight);
        
        // Ground
        const groundGeometry = new THREE.PlaneGeometry(500, 500);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x333333,
            roughness: 0.8
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI/2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Buildings
        function createBuilding(x, z, width, height, depth, color) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.7
            });
            const building = new THREE.Mesh(geometry, material);
            building.position.set(x, height/2, z);
            building.castShadow = true;
            building.receiveShadow = true;
            scene.add(building);
            
            // Add windows if building is tall enough
            if(height > 20) {
                const windowGeometry = new THREE.PlaneGeometry(width-2, height-5);
                const windowMaterial = new THREE.MeshStandardMaterial({
                    color: 0x88ccff,
                    emissive: 0x111111,
                    emissiveIntensity: 0.2,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const windows = new THREE.Mesh(windowGeometry, windowMaterial);
                windows.position.set(x, height/2, z + depth/2 + 0.1);
                windows.rotation.y = Math.PI;
                scene.add(windows);
            }
            
            return building;
        }
        
        // Create city grid
        const buildingColors = [0xaaaaaa, 0xbbbbbb, 0x999999, 0xcccccc];
        for(let x = -150; x <= 150; x += 50) {
            for(let z = -150; z <= 150; z += 50) {
                if(Math.random() > 0.3) {
                    const height = 10 + Math.random() * 50;
                    const width = 10 + Math.random() * 15;
                    const depth = 10 + Math.random() * 15;
                    const color = buildingColors[Math.floor(Math.random() * buildingColors.length)];
                    
                    createBuilding(x, z, width, height, depth, color);
                }
            }
        }
        
        // Roads
        const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
        for(let x = -200; x <= 200; x += 50) {
            const road = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 500),
                roadMaterial
            );
            road.rotation.x = -Math.PI/2;
            road.position.set(x, 0.1, 0);
            scene.add(road);
        }
        for(let z = -200; z <= 200; z += 50) {
            const road = new THREE.Mesh(
                new THREE.PlaneGeometry(500, 10),
                roadMaterial
            );
            road.rotation.x = -Math.PI/2;
            road.position.set(0, 0.1, z);
            scene.add(road);
        }
        
        // Hide loading message when ready
        loadingElement.style.display = 'none';
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html><!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D City</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial;
            text-shadow: 1px 1px 1px black;
            pointer-events: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial;
            font-size: 24px;
            text-shadow: 1px 1px 1px black;
        }
    </style>
</head>
<body>
    <div id="info">Drag to look around | Scroll to zoom</div>
    <div id="loading">Loading 3D City...</div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Show loading message
        const loadingElement = document.getElementById('loading');
        
        // Main scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        
        // Renderer with antialiasing
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // Camera
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 100);
        
        // Controls (mouse/touch)
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 30;
        controls.maxDistance = 200;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        
        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 1024;
        sunLight.shadow.mapSize.height = 1024;
        scene.add(sunLight);
        
        // Ground
        const groundGeometry = new THREE.PlaneGeometry(500, 500);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x333333,
            roughness: 0.8
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI/2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Buildings
        function createBuilding(x, z, width, height, depth, color) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.7
            });
            const building = new THREE.Mesh(geometry, material);
            building.position.set(x, height/2, z);
            building.castShadow = true;
            building.receiveShadow = true;
            scene.add(building);
            
            // Add windows if building is tall enough
            if(height > 20) {
                const windowGeometry = new THREE.PlaneGeometry(width-2, height-5);
                const windowMaterial = new THREE.MeshStandardMaterial({
                    color: 0x88ccff,
                    emissive: 0x111111,
                    emissiveIntensity: 0.2,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const windows = new THREE.Mesh(windowGeometry, windowMaterial);
                windows.position.set(x, height/2, z + depth/2 + 0.1);
                windows.rotation.y = Math.PI;
                scene.add(windows);
            }
            
            return building;
        }
        
        // Create city grid
        const buildingColors = [0xaaaaaa, 0xbbbbbb, 0x999999, 0xcccccc];
        for(let x = -150; x <= 150; x += 50) {
            for(let z = -150; z <= 150; z += 50) {
                if(Math.random() > 0.3) {
                    const height = 10 + Math.random() * 50;
                    const width = 10 + Math.random() * 15;
                    const depth = 10 + Math.random() * 15;
                    const color = buildingColors[Math.floor(Math.random() * buildingColors.length)];
                    
                    createBuilding(x, z, width, height, depth, color);
                }
            }
        }
        
        // Roads
        const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
        for(let x = -200; x <= 200; x += 50) {
            const road = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 500),
                roadMaterial
            );
            road.rotation.x = -Math.PI/2;
            road.position.set(x, 0.1, 0);
            scene.add(road);
        }
        for(let z = -200; z <= 200; z += 50) {
            const road = new THREE.Mesh(
                new THREE.PlaneGeometry(500, 10),
                roadMaterial
            );
            road.rotation.x = -Math.PI/2;
            road.position.set(0, 0.1, z);
            scene.add(road);
        }
        
        // Hide loading message when ready
        loadingElement.style.display = 'none';
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html><!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D City</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial;
            text-shadow: 1px 1px 1px black;
            pointer-events: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial;
            font-size: 24px;
            text-shadow: 1px 1px 1px black;
        }
    </style>
</head>
<body>
    <div id="info">Drag to look around | Scroll to zoom</div>
    <div id="loading">Loading 3D City...</div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Show loading message
        const loadingElement = document.getElementById('loading');
        
        // Main scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        
        // Renderer with antialiasing
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // Camera
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 100);
        
        // Controls (mouse/touch)
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 30;
        controls.maxDistance = 200;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        
        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 1024;
        sunLight.shadow.mapSize.height = 1024;
        scene.add(sunLight);
        
        // Ground
        const groundGeometry = new THREE.PlaneGeometry(500, 500);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x333333,
            roughness: 0.8
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI/2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Buildings
        function createBuilding(x, z, width, height, depth, color) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.7
            });
            const building = new THREE.Mesh(geometry, material);
            building.position.set(x, height/2, z);
            building.castShadow = true;
            building.receiveShadow = true;
            scene.add(building);
            
            // Add windows if building is tall enough
            if(height > 20) {
                const windowGeometry = new THREE.PlaneGeometry(width-2, height-5);
                const windowMaterial = new THREE.MeshStandardMaterial({
                    color: 0x88ccff,
                    emissive: 0x111111,
                    emissiveIntensity: 0.2,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const windows = new THREE.Mesh(windowGeometry, windowMaterial);
                windows.position.set(x, height/2, z + depth/2 + 0.1);
                windows.rotation.y = Math.PI;
                scene.add(windows);
            }
            
            return building;
        }
        
        // Create city grid
        const buildingColors = [0xaaaaaa, 0xbbbbbb, 0x999999, 0xcccccc];
        for(let x = -150; x <= 150; x += 50) {
            for(let z = -150; z <= 150; z += 50) {
                if(Math.random() > 0.3) {
                    const height = 10 + Math.random() * 50;
                    const width = 10 + Math.random() * 15;
                    const depth = 10 + Math.random() * 15;
                    const color = buildingColors[Math.floor(Math.random() * buildingColors.length)];
                    
                    createBuilding(x, z, width, height, depth, color);
                }
            }
        }
        
        // Roads
        const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
        for(let x = -200; x <= 200; x += 50) {
            const road = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 500),
                roadMaterial
            );
            road.rotation.x = -Math.PI/2;
            road.position.set(x, 0.1, 0);
            scene.add(road);
        }
        for(let z = -200; z <= 200; z += 50) {
            const road = new THREE.Mesh(
                new THREE.PlaneGeometry(500, 10),
                roadMaterial
            );
            road.rotation.x = -Math.PI/2;
            road.position.set(0, 0.1, z);
            scene.add(road);
        }
        
        // Hide loading message when ready
        loadingElement.style.display = 'none';
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
